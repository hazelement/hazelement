{"pages":[{"title":"About","text":"I used to be a mechanical engineer who worked in the oil and gas industry. The downturn of the oil price has driven thousands of people out of employment and I am one of them. But with my great interest and experience in programming, I started working at a software developer at a startup IT company. The world is brand new to me and I'm learning great things everyday. Then one day I decided that I should start tracking down my learning progress. It could be useful for my own personal reference and also benefit people who is or will be taking a similar path to become a programmer. Hence I started this blog. Harry, signing off on Nov 19, 2016.","tags":"pages","url":"https://hazelement.github.io/pages/about.html"},{"title":"Contact","text":"Feel free to leave me a comment or contact me through my github profile.","tags":"pages","url":"https://hazelement.github.io/pages/contact.html"},{"title":"MarkDownSample","text":"This is the content of my super blog post.","tags":"pages","url":"https://hazelement.github.io/pages/markdownsample.html"},{"title":"RSTSample","text":"This is another post from rst file.","tags":"example","url":"https://hazelement.github.io/pages/rstsample.html"},{"title":"Setup Jenkins with Django for Continous Deployment","text":"About Jenkins Jenkins is a tool that is widely used for continous integration/deployment. It's basically a tool to automate the process of writing code, running tests and deploy for production. We will be using this post to demonstrate the setup using a \"hello world\" Django web application. The web application will be served using apache. However, the setup can be used with any web development language and framework. The Setup Our development code will be sitting at ~/django_hello_world. For simplicity, the source code will be pushed to a git repository that is sitting on the same machine at /webapp_repo. It can be on other machine through a ssh tunnel. The production code, which is also our live code, will be sitting at /webapps/django_hello_world Django Hello World First thing first, we need to setup an web application first. This will be a similar version of the official Django tutorial, https://docs.djangoproject.com/en/1.10/intro/tutorial01/ . Start the Django project: cd ~/django_hello_world django-admin startproject hello_world Under the same directory, create an app called polls: python manage.py startapp polls This will create a folder called polls. Under polls, open up the file called views and put the following code: from django.http import HttpResponse def index ( request ): return HttpResponse ( \"Hello, world. You're at the polls index.\" ) In the same polls folder, create a file named \"urls.py\" which will define the urls. In the urls file, enter the following code: from django.conf.urls import url from . import views urlpatterns = [ url ( r '&#94;$' , views . index , name = 'index' ), ] Now let's link this url file to the global url file. Open up the urls.py file under hello world folder and put in the following code: from django.conf.urls import url , include from django.contrib import admin urlpatterns = [ url ( r '&#94;polls/' , include ( 'polls.urls' )), url ( r '&#94;admin/' , admin . site . urls ), ] And that's it! Go back to project root directory: cd ~/django_hello_world And run this command: python manage.py runserver Open up http://localhost:8000/polls/ in the browser and we should see the text \"Hello, world. You're at the polls index.\" Remember this only runs our web application under local host, and only we can see it. In order for other people to see it, we need to use apache to serve it. Serve Django with Apache Django's tutorial website has a thorough documentation on the setup, https://docs.djangoproject.com/en/1.10/howto/deployment/wsgi/modwsgi/ . We will briefly mention it here. Using mod_wsgi daemon mode is the recommended way to serve our application. Assuming we have apache and mod_wsgi installed. First of all, let's create a directory to store our production files where Jenkins will be publishing to. cd / mkdir /webapps/hello_world Our production code will be sitting under this directory, hello_world/ hello_world/ polls/ ... Under apache's enabled site directory, let's create a conf file for our web application. cd /etc/apache2/sites-enabled touch hello_world.conf In hello_world.conf, enter the following contents, Listen 8888 <VirtualHost *:8888> # The ServerName directive sets the request scheme, hostname and port that # the server uses to identify itself. This is used when creating # redirection URLs. In the context of virtual hosts, the ServerName # specifies what hostname must appear in the request's Host: header to # match this virtual host. For the default virtual host (this file) this # value is not decisive as it is used as a last resort host regardless. # However, you must set it for any further virtual host explicitly. #ServerName www.example.com # ServerAdmin webmaster@localhost # DocumentRoot /var/www/html # Available loglevels: trace8, ..., trace1, debug, info, notice, warn, # error, crit, alert, emerg. # It is also possible to configure the loglevel for particular # modules, e.g. # LogLevel info ssl:warn WSGIScriptAlias / /webapps/hello_world/hello_world/wsgi.py WSGIDaemonProcess helloworld.com python-path = /django_hello_world WSGIProcessGroup helloworld.com <Directory> /webapps/hello_world/hello_world> <Files wsgi.py> Require all granted </Files> </Directory> ErrorLog ${ APACHE_LOG_DIR } /error.log CustomLog ${ APACHE_LOG_DIR } /access.log combined # For most configuration files from conf-available/, which are # enabled or disabled at a global level, it is possible to # include a line for only one particular virtual host. For example the # following line enables the CGI configuration for this host only # after it has been globally disabled with \"a2disconf\". #Include conf-available/serve-cgi-bin.conf </VirtualHost> This document tells apache about configurations of our site. Apache will be listening on port 8888 and our site should be accessible on port 8888 at all IP addresses. There is a wsgi.py file we need to create for apache to load the Django application. Go back to our development directory, cd ~/django_hello_world/hello_world cd hello_world touch wsgi.py The file structure should look like this, hello_world/ hello_world/ wsgi.py ... polls/ ... In wsgi.py, enter the following content, import os from django.core.wsgi import get_wsgi_application os . environ . setdefault ( \"DJANGO_SETTINGS_MODULE\" , \"hello_world.settings\" ) application = get_wsgi_application () And that's it, we are set for apache. Now let's get our code into our production directory. Setup Git Repository Next setup is to setup the git repository and pull code to our production directory. For simplicity, we will setup the git repository as a local directory on our machine. cd / mkdir git_repo cd git_repo git init --bare hello_world.git This will setup a local git repository under /git_repo called hello_world.git. Next, let setup our development code to track this directory and push our code to it. cd /django_hello_world/hello_world git remote add origin /git_repo/hello_world.git Make our first commit by typing, git status git add --all git commit -a Type in our first commit message and finish the commit. Next let's push our first commit to git repository, git push -u origin master This will push our commit to remote called origin and setup our local master to track the remote master branch. Next let's pull our code into our production directory. cd /webapps git clone /git_repo/hello_world.git Our lastest code should show up in the webapps directory. This is also where apache will be accessing our site code. Restart apache server, sudo systemctl restart apache2 Now, we should be able to see the site under 8888 port, try localhost:8888 or 127.0.0.1:8888 in our web browser. Setup Jenkins to Link Everything First thing first, let's install Jenkins. Follow the instructions on the website, https://wiki.jenkins-ci.org/display/JENKINS/Installing+Jenkins+on+Ubuntu . wget -q -O - https://pkg.jenkins.io/debian/jenkins-ci.org.key | sudo apt-key add - sudo sh -c 'echo deb http://pkg.jenkins.io/debian-stable binary/ > /etc/apt/sources.list.d/jenkins.list' sudo apt-get update sudo apt-get install jenkins Jenkins need JDK and JRE installed to run, install them first if your machine doesn't have them. After installation, check status of Jenkins and make sure it's running, sudo service jenkins status If Jenkins is not running, start it with, sudo service jenkins start Now, open up browser and go to localhost:8080, this is where Jenkins is served. At first time, Jenkins will ask your to create an admin account, just follow the steps to create the admin account. Create a New Build Configuration At Jenkins's home page, click New Item to create an entry for our project. Enter \"hellow world\" for the item name and select Freestyle project . On the next pages, where are a few tabs we need to go through. Under Source Code Management , select Git . A new sub window will appear. Enter \"/git_repo/hello_world.git\" for Repository URL* . This is where we setup our git repository. Leave Credentials as \"none\" as we don't have authentification to access this repository. Leave Brances to build as \"*/master\". Under Build Triggers , check Build periodically , and enter \"H/10 * * * *\" fpr Schedule , this will check for any changes every 10 minutes. Also check Build when a change is pushed to GitHub , this will trigger Jenkins to run whenever a change checked in. Under Build , this is where we will be entering our build script, type in the following, cd /webapps/hello_world python manage.py migrate python manage.py test --noinput hello_world polls sudo systemctl restart apache2 This is also where we can run our test scripts before make our changes live. Click save and we should be good. In the next page, which is also where our project dash board, click Build Now and once its finished, we can see the latest build result under Build History . Make a Simple Change and See It Becomes Live Let's make a change to our source code and test if our Jenkins does the job. cd ~/django_hello_world/hello_world/polls In the \"views.py\" file, we had the code as following, from django.http import HttpResponse def index ( request ): return HttpResponse ( \"Hello, world. You're at the polls index.\" ) from django.http import HttpResponse def index ( request ): return HttpResponse ( \"Hello, world. You're at the polls index. An update on the polls index from Jenkins\" ) Commit and push the new changes, git commit -a git push Now go to localhost:8888, we should be able to see our change becomes live once Jenkins finish the new build. And that's it, we just setup our first continous integration system.","tags":"Jenkins","url":"https://hazelement.github.io/setup-jenkins-with-django-for-continous-deployment.html"},{"title":"Setup Pelican for Github User Pages","text":"For those who don't know. Github has this Pages utility which allow each user to setup a personal sub-domain under Github, functioning like a personal blog. It uses a unique git repo for each user to server its file content. For details, check out their website, https://pages.github.com . There are two types of Github Pages, Project Pages and User Pages. Setting up Project Pages is straight forward. I will be discussing setting up User Pages and some tricks I used to streamline the publishing process. About Github Pages Files of a Github page reside in a very specific Github repository that is owned and unique to each user. They look like this format, yourname.github.io, where \"yourname\" is your Github name. The repository has to follow this format otherwise, it won't work. Go ahead and create a new repository named yourname.github.io. Once that's setup, you can see it on your Github profile and it is waiting for a init push. Now let's get back to our Pelican project. We don't need to clone it to our local disk. Pushings Pelican Output to Github Repo The idea is basically to push Pelican's output folder to the Github repository we just created. To achive this, we have a great tool called ghp-import . We can install it easily with the following command: pip install ghp-import A normal command using ghp-import is like follows: pelican content -o output -s pelicanconf.py ghp-import output git push git@github.com:username/username.github.io.git gh-pages:master The first line generate all rst documents into our output folder. ghp-import then import this output folder into a git branch called gh-pages. Then the last line push this branch to its remote repository which is our Github User Pages repo, yourname.github.io. gh-pages is our local branch and master is our remote repository branch. Please note that the remote branch must be the master branch for it to work properly. The last command will prompt your enter your username and password. Simply enter that, our output folder should be pushed to the repo successfully. Now open up browser and enter username.github.io and we can see our blog live on the web. Github 2-step Authentification If you have 2-step Authentification setup on Github account, using the git push command might not work for you as it doesn't implement a way for you to enter the second passcode. There are 2 ways to solve this problem, one way is to generate a app hash string passcode from Github and use it while doing git push. It's annoying as we have to keep that somewhere and we need to enter that everytime we perform a push. Another easier way is to generate a ssh and put your public key to github. Github SSH Access There are many tutorials on how to generate a SSH key pair. A SSH key pair contains a private key and a public key. A private key is our personal key and we should alway keep secret. A public key is like a lock that matches our private key. When we need to access some machine remotely, we give public key to remote mahine manager and he can install it to his machine. It's like installing our lock onto his house's front door (in this case, his house would be the machine). So we can get into his house with our prviate key. And of course, he can setup locks that comes from other people, ie his door can have many locks and each lock can open his door. If you are using a linux machine, a quick way to generate a key pair is to use ssh-keygen. ssh-keygen -t rsa -C \"your_email@example.com\" This will generate two files, id_rsa, and id_rsa.pub. Open id_rsa.pub with any text editor and copy its entire content. Now let's put this public key to our Github account so that we can use our private key to access Github. In https://github.com/settings/keys , we have a section to add new public key. Paste everything from public key into \"Key\" section and name \"title\" to \"mySSHKey\". And click on add SSH key. We should be good to go. Next time when we do a git push, it should stop asking us about our password. Streamline With A Script We can stream line the publishing process with a bash script. Let's first go to our project root folder and create a file called pubish. touch publish In this file, let's enter the following content #!/bin/bash pelican content -o output -s pelicanconf.py ghp-import output git push git@github.com:username/username.github.io.git gh-pages:master Making this file executable: chmod +x publish We just created a script to perform the publishing process for us. To publish new content, simply enter this command under project root directory. ./publish It should perform all the task for us.","tags":"Pelican","url":"https://hazelement.github.io/setup-pelican-for-github-user-pages.html"},{"title":"Using Pelican for Blogging","text":"Pelican is a popular static website generator written in Python. It saves bloggers from worrying about formats so that they can focus on the content itself. Pelican to bloggers is like Latex to document writters. Pelican take advantage of Markdown and reStructured text (rst) to generated formatted texts. I wrote this website usig rst. Markdown is also a good option as well. Get started Pelican has a great tutorial covering the basic steps to setup a website to play with. http://docs.getpelican.com/en/stable/quickstart.html . Here is a brief summary of that page. Installation To install pelican with pip: pip install pelican If we are using markdown, we can install it with pip too: pip install markdown Create a project A directory must be created for our new project: mkdir -p ~/pelican_tutorial cd pelican_tutorial Once we are in our project directory, we can create a project using the following command: pelican-quickstart Pelican then will ask us a few questions regarding your website. Don't worry if we are not sure on some of these questions, all these options can be changed afterwards. An example of these questions are here: Welcome to pelican-quickstart v3.6.3. This script will help you create a new Pelican-based website. Please answer the following questions so this script can generate the files needed by Pelican. > Where do you want to create your new web site? [ . ] > What will be the title of this web site? my_first_blog > Who will be the author of this web site? haze > What will be the default language of this web site? [ en ] > Do you want to specify a URL prefix? e.g., http://example.com ( Y/n ) n > Do you want to enable article pagination? ( Y/n ) y > How many articles per page do you want? [ 10 ] > What is your time zone? [ Europe/Paris ] > Do you want to generate a Fabfile/Makefile to automate generation and publishing? ( Y/n ) y > Do you want an auto-reload & simpleHTTP script to assist with theme and site development? ( Y/n ) y > Do you want to upload your website using FTP? ( y/N ) n > Do you want to upload your website using SSH? ( y/N ) n > Do you want to upload your website using Dropbox? ( y/N ) n > Do you want to upload your website using S3? ( y/N ) n > Do you want to upload your website using Rackspace Cloud Files? ( y/N ) n > Do you want to upload your website using GitHub Pages? ( y/N ) n Done. Your new project is available at /xxx/pelican_tutorial Create an articles with category Next we are going to create our first post with a category specified. In plelican, each post is a rst file stored within the cotent directory. ~/pelican_tutorial/content Although, categories can be specified within rst file similar to a tag. I prefer to take advantage of folders to put my rst files into each category. In the content folder, if we created folders and put our rst file in each sub folder. Then each folder will be considered as a category. ~/pelican_tutorial/tutorial We just created a tutorial category. And let's create our first post under this category. cd ~/pelican_tutorial/tutorial touch myfirst_tutorial.rst We can then input content to this rst file. For example: My first tutorial ######################## :date: 2016-11-19 11:30 :tags: reStructured text, rst :authors: Haze ===== Title ===== Subtitle -------- This is a paragraph. Save this file, and we are ready to generate our first post into html file. Generate site From site root directory cd ~/pelican_tutorial Run the following code to generate your site: pelican content A folder called output will be generated. This is where our site sits. To see how our site looks like, enter output directory: cd output Run the local pelican server: python -m pelican.server Open up web browser, and type in http://localhost:8000/ , we should see the website served from local directory. Some tips Autosite updates Usually we would like to see our website updates live while we changing the rst file contents, especially during development. This can be achieved by running the following command. make regenerate \"make\" is a script at the project root folder. Don't close terminal after running this command as the script is monitoring our project folder to detect any changes. We can continous editing and saving your rst file. All changes will be reflected on your local website. Althought we need to refresh the page of course. One drawback with this script is that if we have a syntax error in the rst file, it will likely crash the script and we would have to restart it again after fixing the syntax. For popular rst syntax, check out my other post, reStructured Text Syntax . Next up, Setup Pelican for Github User Pages .","tags":"Pelican","url":"https://hazelement.github.io/using-pelican-for-blogging.html"},{"title":"reStructured Text Syntax","text":"A page with popular reStructured Text Syntax A page with popular reStructured Text Syntax A page with popular reStructured Text Syntax Title Subtitle This is a paragraph. Paragraphs line up at their left edges, and are normally separated by blank lines. Plain text Typical result This is a normal text paragraph. The next paragraph is a code sample: It is not processed in any way, except that the indentation is removed. It can span multiple lines. This is a normal text paragraph again. Bullet lists: This is item 1 This is item 2 Bullets are \"-\", \"*\" or \"+\". Continuing text must be aligned after the bullet and whitespace. Note that a blank line is required before the first item and after the last, but is optional between items. Enumerated lists: This is the first item This is the second item Enumerators are arabic numbers, single letters, or roman numerals List items should be sequentially numbered, but need not start at 1 (although not all formatters will honour the first index). This item is auto-enumerated Definition lists: what Definition lists associate a term with a definition. how The term is a one-line phrase, and the definition is one or more paragraphs or body elements, indented relative to the term. Blank lines are not allowed between term and definition. Authors: Tony J. (Tibs) Ibbs, David Goodger (and sundry other good-natured folks) Version: 1.0 of 2001/08/08 Dedication: To my father. A paragraph containing only two colons indicates that the following indented or quoted text is a literal block. Whitespace, newlines, blank lines, and all kinds of markup (like *this* or \\this) is preserved by literal blocks. The paragraph containing only '::' will be omitted from the result. The :: may be tacked onto the very end of any paragraph. The :: will be omitted if it is preceded by whitespace. The :: will be converted to a single colon if preceded by text, like this: It's very convenient to use this form. Literal blocks end when text returns to the preceding paragraph's indentation. This means that something like this is possible: We start here and continue here and end here. Per-line quoting can also be used on unindented literal blocks: > Useful for quotes from email and > for Haskell literate programming. Grid table: Header 1 Header 2 Header 3 body row 1 column 2 column 3 body row 2 Cells may span columns. body row 3 Cells may span rows. Cells contain blocks. body row 4 Simple table: Inputs Output A B A or B False False False True False True False True True True True True External hyperlinks, like Python . Internal crossreferences, like example .","tags":"reStructuredText","url":"https://hazelement.github.io/restructured-text-syntax.html"}]}